// Copyright 2010 Chris Williams <chris@iterativedesigns.com>
#include "serialport_native.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <string.h>
#include <errno.h>
#include <limits.h>

#include <termios.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/signal.h>
#include <sys/types.h>

#include <node.h>
#include <node_buffer.h>
#include <v8.h>


#define GET_OFFSET(a) (a)->IsInt32() ? (a)->IntegerValue() : -1;

#define THROW_BAD_ARGS ThrowException(Exception::TypeError(String::New("Bad argument")))

#define ASYNC_CALL(func, callback, ...)                           \
  eio_req *req = eio_##func(__VA_ARGS__, EIO_PRI_DEFAULT, After,  \
    cb_persist(callback));                                        \
  assert(req);                                                    \
  ev_ref(EV_DEFAULT_UC);                                          \
  return Undefined();


namespace node {

  using namespace v8;

  static Persistent<String> buf_symbol;

  static inline Local<Value> errno_exception(int errorno) {
    Local<Value> e = Exception::Error(String::NewSymbol(strerror(errorno)));
    Local<Object> obj = e->ToObject();
    obj->Set(NODE_PSYMBOL("errno"), Integer::New(errorno));
    return e;
  }
  
  
  static Handle<Value> Read(const Arguments& args) {
    HandleScope scope;
    
    
    if (args.Length() < 2 || !args[0]->IsInt32()) {
      return ThrowException(Exception::TypeError(String::New("Bad arguments")));
    }
    // 
    // if (args.Length() != 2) {
    //   return ThrowException(Exception::TypeError(String::New("Read takes exactly two arguments")));
    // }
    // if (!args[0]->IsInt32()) {
    //     return ThrowException(Exception::TypeError(String::New("First argument must be an fd")));
    // }
    // if (!Buffer::HasInstance(args[1])) {
    //     return ThrowException(Exception::TypeError(String::New("Second argument must be a buffer")));
    // }
 
    int fd = args[0]->Int32Value();
    Local<Value> cb;
    
    size_t len;
    off_t pos;

    char * buf = NULL;

    if (!Buffer::HasInstance(args[1])) {
      return ThrowException(Exception::Error(
                  String::New("Second argument needs to be a buffer")));
    }

    Local<Object> buffer_obj = args[1]->ToObject();
    char *buffer_data = Buffer::Data(buffer_obj);
    size_t buffer_length = Buffer::Length(buffer_obj);
    
    
    size_t off = args[2]->Int32Value();
    if (off >= buffer_length) {
      return ThrowException(Exception::Error(
            String::New("Offset is out of bounds")));
    }

    len = args[3]->Int32Value();
    if (off + len > buffer_length) {
      return ThrowException(Exception::Error(
            String::New("Length is extends beyond buffer")));
    }

    pos = GET_OFFSET(args[4]);

    buf = buffer_data + off;

    cb = args[5];
    
    // Buffer *buffer = ObjectWrap::Unwrap<Buffer>(args[1]->ToObject());
    // int buffer_length = buffer->length();
    // char *buffer_data = (char*)buffer->data();

    // int bytes_read = read(fd, buffer_data, buffer_length);
    // return scope.Close(Integer::NewFromUnsigned(bytes_read));
    
    if (cb->IsFunction()) {
      // Grab a reference to buffer so it isn't GCed
      // TODO: need test coverage
      Local<Object> cb_obj = cb->ToObject();
      cb_obj->Set(buf_symbol, buffer_obj);

      // ASYNC_CALL(read, cb, fd, buf, len, pos);
    } else {
      // SYNC
      ssize_t ret;

      ret = pos < 0 ? read(fd, buf, len) : pread(fd, buf, len, pos);
      if (ret < 0) return ThrowException(ErrnoException(errno));
      Local<Integer> bytesRead = Integer::New(ret);
      return scope.Close(bytesRead);
    }
        // 
        // 
        // ssize_t ret;
        // 
        // ret = pos < 0 ? read(fd, buf, len) : pread(fd, buf, len, pos);
        // if (ret < 0) return ThrowException(ErrnoException(errno));
        // Local<Integer> bytesRead = Integer::New(ret);
        // return scope.Close(bytesRead);
  }
  
  static Handle<Value> Open(const Arguments& args) {
    HandleScope scope;

    struct termios newtio; 

    long Baud_Rate = 38400;
    int Data_Bits = 8;
    int Stop_Bits = 1;
    int Parity = 0;

    long BAUD;
    long DATABITS;
    long STOPBITS;
    long PARITYON;
    long PARITY;

    if (!args[0]->IsString()) {
      return scope.Close(THROW_BAD_ARGS);
    }
    
    // Baud Rate Argument
    if (args.Length() >= 2 && !args[1]->IsInt32()) {
      return scope.Close(THROW_BAD_ARGS);
    } else {
      Baud_Rate = args[1]->Int32Value();
    }

    // Data Bits Argument
    if (args.Length() >= 3 && !args[2]->IsInt32()) {
      return scope.Close(THROW_BAD_ARGS);
    } else {
      Data_Bits = args[2]->Int32Value();
    }

    // Stop Bits Arguments
    if (args.Length() >= 4 && !args[3]->IsInt32()) {
      return scope.Close(THROW_BAD_ARGS);
    } else {
      Stop_Bits = args[2]->Int32Value();
    }

    // Parity Arguments
    if (args.Length() >= 5 && !args[4]->IsInt32()) {
      return scope.Close(THROW_BAD_ARGS);
    } else {
      Parity = args[2]->Int32Value();
    }






    switch (Baud_Rate)
      {
      case 38400:
      default:
        BAUD = B38400;
        break;
      case 115200:
        BAUD = B115200;
        break;

      case 57600:
        BAUD = B57600;
        break;
      case 19200:
        BAUD  = B19200;
        break;
      case 9600:
        BAUD  = B9600;
        break;
      case 4800:
        BAUD  = B4800;
        break;
      case 2400:
        BAUD  = B2400;
        break;
      case 1800:
        BAUD  = B1800;
        break;
      case 1200:
        BAUD  = B1200;
        break;
      case 600:
        BAUD  = B600;
        break;
      case 300:
        BAUD  = B300;
        break;
      case 200:
        BAUD  = B200;
        break;
      case 150:
        BAUD  = B150;
        break;
      case 134:
        BAUD  = B134;
        break;
      case 110:
        BAUD  = B110;
        break;
      case 75:
        BAUD  = B75;
        break;
      case 50:
        BAUD  = B50;
        break;
      }
    
    switch (Data_Bits)
      {
      case 8:
      default:
        DATABITS = CS8;
        break;
      case 7:
        DATABITS = CS7;
        break;
      case 6:
        DATABITS = CS6;
        break;
      case 5:
        DATABITS = CS5;
        break;
      }
    switch (Stop_Bits)
      {
      case 1:
      default:
        STOPBITS = 0;
        break;
      case 2:
        STOPBITS = CSTOPB;
        break;
      } 


    switch (Parity)
      {
      case 0:
      default:                       //none
        PARITYON = 0;
        PARITY = 0;
        break;
      case 1:                        //odd
        PARITYON = PARENB;
        PARITY = PARODD;
        break;
      case 2:                        //even
        PARITYON = PARENB;
        PARITY = 0;
        break;
      }


    String::Utf8Value path(args[0]->ToString());
    
    int flags = (O_RDWR | O_NOCTTY | O_NONBLOCK);
    
    int fd = open(*path, flags);
    if (fd < 0) return scope.Close(ThrowException(errno_exception(errno)));

    struct sigaction saio; 
    saio.sa_handler = SIG_IGN;
    sigemptyset(&saio.sa_mask);   //saio.sa_mask = 0;
    saio.sa_flags = 0;
    //    saio.sa_restorer = NULL;
    sigaction(SIGIO,&saio,NULL);

    //all process to receive SIGIO
    fcntl(fd, F_SETOWN, getpid());
    fcntl(fd, F_SETFL, FASYNC);


    newtio.c_cflag = BAUD | CRTSCTS | DATABITS | STOPBITS | PARITYON | PARITY | CLOCAL | CREAD;
    newtio.c_iflag = IGNPAR;
    newtio.c_oflag = 0;
    newtio.c_lflag = 0;       //ICANON;
    newtio.c_cc[VMIN]=1;
    newtio.c_cc[VTIME]=0;
    tcflush(fd, TCIFLUSH);
    tcsetattr(fd,TCSANOW,&newtio);
    return scope.Close(Integer::New(fd));
  }




  static Handle<Value>
    Write (const Arguments& args)
    {
      HandleScope scope;

      size_t written = 0;
      
      if (!args[0]->IsInt32())  {
        return scope.Close(THROW_BAD_ARGS);
      }
      int fd = args[0]->Int32Value();
      
      if (!Buffer::HasInstance(args[1])) {
        return ThrowException(Exception::Error(
                    String::New("Second argument needs to be a buffer")));
      }

      Local<Object> buffer_obj = args[1]->ToObject();
      char *buffer_data = Buffer::Data(buffer_obj);
      size_t buffer_length = Buffer::Length(buffer_obj);
      
      
      size_t off = args[2]->Int32Value();
      if (off >= buffer_length) {
        return ThrowException(Exception::Error(
              String::New("Offset is out of bounds")));
      }

      ssize_t len = args[3]->Int32Value();
      if (off + len > buffer_length) {
        return ThrowException(Exception::Error(
              String::New("Length is extends beyond buffer")));
      }

      off_t pos = GET_OFFSET(args[4]);

      char * buf = (char*)buffer_data + off;
      Local<Value> cb = args[5];


      if (cb->IsFunction()) {
        // Grab a reference to buffer so it isn't GCed
        Local<Object> cb_obj = cb->ToObject();
        cb_obj->Set(buf_symbol, buffer_obj);

        // ASYNC_CALL(write, cb, fd, buf, len, pos)
      } else {
        ssize_t written = pos < 0 ? write(fd, buf, len) : pwrite(fd, buf, len, pos);
        if (written < 0) return ThrowException(ErrnoException(errno, "write"));
        return scope.Close(Integer::New(written));
      }

      // if (args[1]->IsString()) {
      //   String::Utf8Value buffer(args[1]->ToString());
      //   written = write(fd, *buffer, buffer.length());
      // } else if (Buffer::HasInstance(args[1])) {
      //   Buffer * buffer = ObjectWrap::Unwrap<Buffer>(args[1]->ToObject());
      //   size_t buffer_length = buffer->length();
      //   char * buf = (char*)buffer->data();
      //   if (buffer_length < 0) {
      //     return ThrowException(Exception::TypeError(String::New("Bad argument")));
      //   }
      //   written = write(fd, buf, buffer_length);
      // } else {
      //   return scope.Close(ThrowException(Exception::Error(String::New("First argument must be a string or buffer."))));
      // }
      // if (written < 0) return ThrowException(Exception::Error(String::NewSymbol(strerror(errno))));
      // return scope.Close(Integer::New(written));
    }



  void SerialPort::Initialize(Handle<Object> target) {
    
    HandleScope scope;
    NODE_SET_METHOD(target, "open", Open);
    NODE_SET_METHOD(target, "write", Write);
    NODE_SET_METHOD(target, "read", Read);
    buf_symbol = NODE_PSYMBOL("__buf"); 
  }


  extern "C" void
  init (Handle<Object> target) 
  {
    HandleScope scope;
    SerialPort::Initialize(target);
  }


}

//-------------



